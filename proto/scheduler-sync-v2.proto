// Scheduler Sync Protocol v2
//
// Bidirectional synchronization protocol between vehicle (onboard) and
// cloud (offboard) scheduler components.
//
// Key features:
// - Version vectors for conflict detection (no wall-clock dependency)
// - Source authority for deterministic conflict resolution
// - Checksum-based quiescence (no traffic when in sync)
// - Append-only execution history
// - Offline support on both sides
//
// See docs/scheduler-sync-protocol-v2.md for full specification.

syntax = "proto3";

package swdv.scheduler_sync_v2;

option cc_enable_arenas = true;

// =============================================================================
// Version Vector
// =============================================================================

// Two-component version vector for conflict detection.
// Each component is incremented by its respective side on any change.
message JobVersion {
    uint64 cloud_seq = 1;       // Incremented by cloud on any change
    uint64 vehicle_seq = 2;     // Incremented by vehicle on any change
}

// =============================================================================
// Enumerations
// =============================================================================

// Who is authoritative for conflicts on this job.
// Set at creation time, immutable thereafter.
// NOTE: Authority is mandatory - every job must have one set at creation.
enum JobAuthority {
    AUTHORITY_CLOUD = 0;        // Cloud wins conflicts (job created by cloud)
    AUTHORITY_VEHICLE = 1;      // Vehicle wins conflicts (job created on vehicle/phone)
}

// Job execution status (vehicle-authoritative, not synced).
enum JobStatus {
    JOB_STATUS_PENDING = 0;     // Waiting to execute
    JOB_STATUS_RUNNING = 1;     // Currently executing
    JOB_STATUS_COMPLETED = 2;   // Finished successfully
    JOB_STATUS_FAILED = 3;      // Execution failed
    JOB_STATUS_CANCELLED = 4;   // Cancelled by user/system
}

// Vehicle wake behavior for scheduled jobs.
enum WakePolicy {
    WAKE_NO_WAKE = 0;           // Only run if vehicle already awake
    WAKE_REQUIRED = 1;          // Wake vehicle via RTC to run job
}

// Vehicle sleep behavior during job execution.
enum SleepPolicy {
    SLEEP_NORMAL = 0;           // Normal sleep after job
    SLEEP_INHIBIT = 1;          // Prevent sleep until job complete
}

// =============================================================================
// Job Record
// =============================================================================

// Complete job record with version tracking.
message JobRecord {
    // --- Identity ---
    string job_id = 1;                  // Namespaced: "cloud-*", "veh-VIN-*", "phone-*"
    JobAuthority authority = 2;         // Who wins conflicts (immutable after creation)

    // --- Version (for sync protocol) ---
    JobVersion version = 3;             // Version vector

    // --- Lifecycle ---
    bool deleted = 5;                   // Soft delete (tombstone)
    uint64 deleted_at_ms = 6;           // When deleted (for GC)

    // --- Content (included in checksum) - user intent, synced ---
    string title = 10;                  // Human-readable title
    string service = 11;                // Target service name
    string method = 12;                 // Target method name
    string parameters_json = 13;        // JSON-encoded parameters
    uint64 scheduled_time_ms = 14;      // When to run (epoch ms)
    string recurrence_rule = 15;        // iCal RRULE for recurring jobs
    uint64 end_time_ms = 16;            // Stop recurring after this (0 = forever)
    bool paused = 17;                   // User intent: "don't schedule this job"
    WakePolicy wake_policy = 18;        // Whether to wake vehicle for this job
    SleepPolicy sleep_policy = 19;      // Sleep behavior during execution
    uint32 wake_lead_time_s = 20;       // Seconds before scheduled_time to wake

    // --- Execution state (vehicle-authoritative, NOT in checksum) ---
    JobStatus status = 25;              // What's happening now
    uint64 next_run_time_ms = 26;       // Next scheduled run
    uint64 last_executed_ms = 27;       // Last execution timestamp

    // --- Metadata (NOT in checksum) ---
    uint64 created_at_ms = 30;          // Creation timestamp
    uint64 updated_at_ms = 31;          // Last update timestamp
    string created_by = 32;             // User/system that created job
}

// =============================================================================
// Execution Record
// =============================================================================

// Immutable record of a job execution.
// Executions are append-only facts - they never conflict.
message ExecutionRecord {
    string execution_id = 1;            // Globally unique
    string job_id = 2;                  // Job that was executed
    uint64 executed_at_ms = 3;          // When execution started
    uint64 duration_ms = 4;             // Execution duration
    JobStatus status = 5;               // Result: COMPLETED or FAILED
    string result_json = 6;             // JSON result (for COMPLETED)
    string error_message = 7;           // Error message (for FAILED)
}

// =============================================================================
// Sync Messages
// =============================================================================

// Cloud -> Vehicle sync message.
message C2V_SyncMessage {
    string vehicle_id = 1;              // Target vehicle
    repeated JobRecord jobs = 2;        // All jobs: active AND tombstones (deleted=true)
    uint64 sync_timestamp_ms = 3;       // When this message was created

    // Checksum-based quiescence detection
    uint64 state_checksum = 10;         // xxHash64 of current state
    uint64 last_seen_v2c_checksum = 11; // "I've seen your state up to this checksum"
}

// Vehicle -> Cloud sync message.
message V2C_SyncMessage {
    string vehicle_id = 1;              // Source vehicle
    string bridge_instance_id = 2;      // Sync bridge instance (for restart detection)
    repeated JobRecord jobs = 3;        // All jobs: active AND tombstones (deleted=true)
    repeated ExecutionRecord executions = 4;  // New executions since last sync
    uint64 sync_timestamp_ms = 5;       // When this message was created

    // Checksum-based quiescence detection
    uint64 state_checksum = 10;         // xxHash64 of current state
    uint64 last_seen_c2v_checksum = 11; // "I've seen your state up to this checksum"
}

// =============================================================================
// Trigger Command (the only imperative command - not state sync)
// =============================================================================

// Request to immediately execute a job (bypassing schedule).
// This is the ONLY command in the protocol - everything else is state sync.
message TriggerJobRequest {
    string job_id = 1;                  // Job to trigger
    string requester_id = 2;            // Who requested the trigger (for audit)
    uint64 timestamp_ms = 3;            // When request was made
    uint64 expires_at_ms = 4;           // Request expires after this (0 = no expiry)
}

// Response to trigger request.
message TriggerJobResponse {
    string job_id = 1;                  // Job that was triggered
    bool accepted = 2;                  // Whether job will run
    string error_message = 3;           // Why not accepted (if !accepted)
    uint64 timestamp_ms = 4;            // When response was created
}
